#if UNITY_EDITOR

using System.Linq;
using System.Collections;
using System.Collections.Generic;
using Newtonsoft.Json.Linq;
using UnityEngine;

using ECellDive.Interfaces;
using ECellDive.Modules;
using UnityEditor;

namespace ECellDive.CustomEditors
{
    public class ComputeFBADev : ATServerInterface
    {
        public CyJsonModule cyJsonDataHolder;
        public float minFluxLevelsClamp;
        public float maxFluxLevelsClamp;
        private FbaAnalysisData fbaAnalysisData;

        public void InitializeFbaAnalysisData()
        {
            fbaAnalysisData = new FbaAnalysisData
            {
                activeModelName = "",
                objectiveValue = 0f,
                edgeName_to_EdgeID = new Dictionary<string, List<uint>>(),
                knockOuts = new Dictionary<uint, bool>(),
                fluxes = new Dictionary<string, float>()
            };

            fbaAnalysisData.activeModelName = cyJsonDataHolder.graphData.name;

            Debug.Log($"FBA analyses module connected to {fbaAnalysisData.activeModelName}");

            foreach (IEdge _edgeData in cyJsonDataHolder.graphData.edges)
            {
                Debug.Log($"adding {cyJsonDataHolder.graphData.edges}");
                fbaAnalysisData.knockOuts[_edgeData.ID] = false;
                string _name = _edgeData.name;
                if (fbaAnalysisData.edgeName_to_EdgeID.ContainsKey(_name))
                {
                    fbaAnalysisData.edgeName_to_EdgeID[_name].Add(_edgeData.ID);
                }
                else
                {
                    fbaAnalysisData.edgeName_to_EdgeID[_name] = new List<uint> { _edgeData.ID };
                }
            }
        }

        /// <summary>
        /// Translates the information about knockedout reactions stored
        /// as a string usable for a request to the server.
        /// </summary>
        /// <returns>A string listing the knockedout reactions.</returns>
        private string GetKnockoutString()
        {
            string knockouts = "";
            int counter_true = 0;
            Dictionary<string, ushort> reactionMatch = new Dictionary<string, ushort>();
            ushort reactionMatchCount = 0;
            foreach (IEdge _edgeData in cyJsonDataHolder.graphData.edges)
            {
                if (cyJsonDataHolder.DataID_to_DataGO[_edgeData.ID].GetComponent<EdgeGO>().knockedOut.Value)
                {
                    if (!reactionMatch.TryGetValue(_edgeData.name, out reactionMatchCount))
                    {
                        reactionMatch[_edgeData.name] = 1;
                        knockouts += "knockout_" + _edgeData.ID + ",";
                        counter_true++;
                    }
                }
            }

            if (counter_true > 0)
            {
                knockouts = knockouts.Substring(0, knockouts.Length - 1);
            }

            return knockouts;
        }

        /// <summary>
        /// Builds and sends the URI of the request that should activate the
        /// computation of the FBA on the server.
        /// </summary>
        /// <param name="_modelName">The name of the model as stored
        /// in the server.</param>
        /// <param name="_knockouts">The string listing the names of
        /// the knockedout reactions. The string can be generated by
        /// the <see cref="GetKnockoutString"/></param>
        private void GetModelSolution(string _modelName, string _knockouts)
        {
            string requestURL = AddPagesToURL(new string[] { "solve2", _modelName });
            if (_knockouts != "")
            {
                requestURL = AddQueriesToURL(requestURL,
                    new string[] { "modification", "view_name" },
                    new string[] { _knockouts, cyJsonDataHolder.graphData.name });
            }
            StartCoroutine(GetRequest(requestURL));
        }

        /// <summary>
        /// Starts the process to ask the server for the FBA of the model.
        /// </summary>
        public void RequestModelSolve()
        {
            string knockoutString = GetKnockoutString();
            StartCoroutine(SolveModelC(fbaAnalysisData.activeModelName, knockoutString));
        }

        public void SaveFluxes()
        {
            FluxDataSerializer fluxDataSerializer = ScriptableObject.CreateInstance<FluxDataSerializer>();

            int count = 0;
            foreach (string _edgeName in fbaAnalysisData.fluxes.Keys)
            {
                if (fbaAnalysisData.edgeName_to_EdgeID.ContainsKey(_edgeName))
                {
                    count += fbaAnalysisData.edgeName_to_EdgeID[_edgeName].Count;
                }
            }

            fluxDataSerializer.data = new FluxData[count];

            count = 0;
            foreach (string _edgeName in fbaAnalysisData.fluxes.Keys)
            {
                if (fbaAnalysisData.edgeName_to_EdgeID.ContainsKey(_edgeName))
                {
                    float level = fbaAnalysisData.fluxes[_edgeName];
                    float levelClamped = Mathf.Clamp(level,
                                                     minFluxLevelsClamp,
                                                     maxFluxLevelsClamp);

                    foreach (uint _id in fbaAnalysisData.edgeName_to_EdgeID[_edgeName])
                    {
                        fluxDataSerializer.data[count] = new FluxData
                        {
                            fluxLevel = level,
                            fluxLevelClamped = levelClamped,
                            targetGoID = _id
                        };
                        count++;
                    }
                }
            }

            AssetDatabase.CreateAsset(fluxDataSerializer, "Assets/Resources/Prefabs/Modules/Demo_iJO1366/" + cyJsonDataHolder.name + "_FluxData.asset");

        }

        /// <summary>
        /// Transfers the results of the FBA (fluxes values) to the shaders
        /// of the edges (representing the reactions).
        /// </summary>
        public void ShowComputedFluxes()
        {
            EdgeGO edgeGO;
            foreach (string _edgeName in fbaAnalysisData.fluxes.Keys)
            {
                if (fbaAnalysisData.edgeName_to_EdgeID.ContainsKey(_edgeName))
                {
                    float level = fbaAnalysisData.fluxes[_edgeName];
                    float levelClamped = Mathf.Clamp(level,
                                                     minFluxLevelsClamp,
                                                     maxFluxLevelsClamp);

                    foreach (uint _id in fbaAnalysisData.edgeName_to_EdgeID[_edgeName])
                    {
                        edgeGO = cyJsonDataHolder.DataID_to_DataGO[_id].GetComponent<EdgeGO>();
                        if ((edgeGO.fluxLevel.Value < 0 && level > 0) || (edgeGO.fluxLevel.Value > 0 && level < 0))
                        {
                            edgeGO.ReverseOrientation();
                        }
                        edgeGO.SetFlux(level, levelClamped);
                        edgeGO.ApplyFluxLevel();
                        edgeGO.ApplyFluxLevelClamped();
                    }
                }
            }
        }

        /// <summary>
        /// The coroutine handling the request to the server and the 
        /// parsing of the FBA results if the request was successful.
        /// </summary>
        /// <param name="_modelName">The name of the model as stored
        /// in the server.</param>
        /// <param name="_knockouts">The string listing the names of
        /// the knockedout reactions. The string can be generated by
        /// the <see cref="GetKnockoutString"/></param>
        private IEnumerator SolveModelC(string _modelName, string _knockouts)
        {
            GetModelSolution(_modelName, _knockouts);

            yield return new WaitUntil(() => requestData.requestProcessed);
            if (requestData.requestSuccess)
            {
                requestData.requestJObject = JObject.Parse(requestData.requestText);
                JArray jFluxesArray = (JArray)requestData.requestJObject["fluxes"];
                fbaAnalysisData.objectiveValue = requestData.requestJObject["objective_value"].Value<float>();

                float maxFlux = float.MinValue;
                float minFlux = float.MaxValue;
                float fluxValue = 0f;
                foreach (JArray _flux in jFluxesArray)
                {
                    fluxValue = _flux.ElementAt(1).Value<float>();
                    fbaAnalysisData.fluxes[_flux.ElementAt(0).Value<string>()] = fluxValue;

                    if (fluxValue > maxFlux)
                    {
                        maxFlux = fluxValue;
                    }
                    else if (fluxValue < minFlux)
                    {
                        minFlux = fluxValue;
                    }
                }

                ShowComputedFluxes();
            }
        }
    }
}
#endif